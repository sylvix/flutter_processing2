# `noise()`

```dart
double noise(double x, [double y = 0, z = 0])
```

Возвращает значение шума Перлина в указанных координатах. Шум Перлина - это генератор случайных последовательностей, создающий более естественную, гармоничную последовательность чисел, чем стандартная функция random(). Он был разработан Кеном Перлином в 1980-х годах и использовался в графических приложениях для создания процедурных текстур, форм, ландшафтов и других кажущихся органичными форм.

В отличие от функции random(), шум Перлина задается в бесконечном n-мерном пространстве, в котором каждой паре координат соответствует фиксированное полуслучайное значение (фиксированное только на время жизни программы). Результирующее значение всегда будет находиться между 0,0 и 1,0. Обработка может вычислять одномерный, двумерный и трехмерный шум в зависимости от количества заданных координат. Значение шума можно анимировать, перемещаясь по пространству шума, как показано в первом примере выше. Второе и третье измерения также могут быть интерпретированы как время.

Фактическая структура шума похожа на структуру аудиосигнала, поскольку в функции используются частоты. Подобно концепции гармоник в физике, шум Перлина вычисляется по нескольким октавам, которые складываются вместе для получения конечного результата.

Еще одним способом настройки характера результирующей последовательности является масштаб входных координат. Поскольку функция работает в бесконечном пространстве, значение координат как таковое не имеет значения; важно только расстояние между последовательными координатами (например, при использовании noise() внутри цикла). Как правило, t

## Пример

```dart
float xoff = 0.0;

void draw() {
  background(204);
  xoff = xoff + 0.01; // Двигаемся по оси X
  float n = noise(xoff) * width; // Получаем значение шума
  line(n, 0, n, height); // Рисуем линию на основе значения шума
}
```

```dart
float noiseScale = 0.02;

void draw() {
  background(0);
  for (int x = 0; x < width; x++) {
    float noiseVal = noise((mouseX + x) * noiseScale, mouseY * noiseScale);
    stroke(noiseVal * 255); // Устанавливаем цвет на основе значения шума
    line(x, mouseY + noiseVal * 80, x, height);
  }
}
```
